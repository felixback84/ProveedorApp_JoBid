var debug = false;


var calculateScore = function(values, cardsWithModifierWeightings) {
  var score = 0;
  for (var i=0; i<cardsWithModifierWeightings.length; i++) {
    var name = cardsWithModifierWeightings[i].name;
    var weighting = cardsWithModifierWeightings[i].weighting;
    if (typeof values[name] === "undefined") {
      throw "The data does not have a '"+name+"'key.";
    }
    score += values[name] * weighting;
  }
  return score;
};


var genBucketSizes = function(numBuckets, numItems) {
  var result = [];
  var numInEachBucket = Math.floor(numItems / numBuckets);
  var remainder = (numItems % numBuckets);
  var bucket = 0;
  while (remainder) {
    result[bucket] = numInEachBucket + 1;
    remainder = remainder - 1;
    bucket += 1;
  }
  while (bucket < numBuckets) {
    result[bucket] = numInEachBucket;
    bucket += 1;
  }
  return result;
};


var calculateScores = function(cardsWithModifierWeightings, data, track) {
  var scores = [];
  var tracked = {};
  if (debug) {
    console.log('calculateScores() track:', track); 
  }
  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      if (debug) {
        console.log(key, data[key], cardsWithModifierWeightings);
      }
      var score = calculateScore(data[key], cardsWithModifierWeightings);
      if (key in track) {
        tracked[key] = score; 
      }
      scores.push(score);
    }
  }
  scores.sort();
  if (debug) {
    console.log('calculateScores() tracked:', tracked); 
  }
  return {
    scores: scores,
    tracked: tracked
  }
};


var calculateUpperBoundaries = function(cardsWithModifierWeightings, data, numBuckets, track) {
  if (debug) {
    console.log(cardsWithModifierWeightings, data, numBuckets);
  }
  // Let's put more in the lowest bucket if necessary
  var res = calculateScores(cardsWithModifierWeightings, data, track);
  if (debug) {
    console.log('Scores:', res.scores);
  }
  var bucketSizes = genBucketSizes(numBuckets, res.scores.length);
  if (debug) {
    console.log('Bucket sizes:', bucketSizes);
  }
  var boundaries = [];
  var total = 0;
  for (var i=0; i<numBuckets-1; i++) {
    total += bucketSizes[i];
    boundaries[i] = res.scores[total-1];
    if (debug) {
      console.log('Upper boundary for bucket', i, 'pos', total-1, 'in scores, is', boundaries[i]);
    }
  }
  if (debug) {
    console.log('calculateUpperBoundaries() tracked:', res.tracked);
  }
  return {
    tracked: res.tracked,
    boundaries: boundaries
  }
};


var calculateBuckets = function(cardsWithModifierWeightings, data, numBuckets, track) {
  if (typeof track === "undefined") {
    // track all the data items
    var track = data;
  }
  if (debug) {
    console.log('calculateBuckets() track:', track);
  }
  var res = calculateUpperBoundaries(cardsWithModifierWeightings, data, numBuckets, track);
  if (debug) {
    console.log('calculateBuckets() tracked:', res.tracked);
  }
  var bucketByKey = {};
  for (var k in track) {
    if (track.hasOwnProperty(k)) {
      bucketByKey[k] = whichBucket(res.boundaries, res.tracked[k])
      if (debug) {
        console.log(k, bucketByKey[k]);
      }
    }
  }
  return {
    tracked: res.tracked,
    boundaries: res.boundaries,
    bucketByKey: bucketByKey
  }
};


var whichBucket = function(upperBoundaries, score) {
  // Take the lowest bucket a score falls into. This means that all scores of a
  // particular value go in the lowest bucket where the first was found. This
  // prevents two entries with the same score appearing in different buckets.
  if (typeof score !== "number") {
    throw "Invalid score: "+score;
  }
  for (var i=0; i<upperBoundaries.length; i++) {
    if (score <= upperBoundaries[i]) {
      return i;
    }
  }
  // Note that there is one less upper boundary, than there are buckets, because
  // we don't care about the highest value
  return upperBoundaries.length;
};


module.exports = {
  calculateBuckets: calculateBuckets,
  calculateScore: calculateScore,
  calculateUpperBoundaries: calculateUpperBoundaries,
  whichBucket: whichBucket
}
