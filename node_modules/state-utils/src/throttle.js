/*
Call func immediately, and then after wait milliseconds no matter how often
it is called. Always use the most recent data, and make sure the last call
is made, even after the wait delay. The optional cmp function allows you to
override the called function if the data happens to be the same.

Returns a throttled and a fireLast function. If you call fireLast, the last
throttled event (if any) will be fired, and the wait cycle will start
again.
~~~
*/


var throttle = function(wait, func, cmp, firstWait) {
  var lastArgs = undefined;
  var nextArgs = undefined;
  var lastSent = null;
  var sendPending = null;
  if (typeof firstWait === "undefined") {
    firstWait = 0;
  }
  var sendNow = function() {
    sendPending = null;
    // console.log('Sending now', nextArgs);
    if (nextArgs) {
      if (cmp && lastArgs) {
        if (cmp(Array.prototype.slice.call(lastArgs), Array.prototype.slice.call(nextArgs))) {
          func.apply(this, nextArgs);
          lastArgs = nextArgs;
        }
      } else {
        func.apply(this, nextArgs);
        lastArgs = nextArgs;
      }
      nextArgs = undefined;
    }
    lastSent = (new Date()).getTime();
  };
  var send = function(delay) {
    if (delay === 0) {
      sendNow();
    } else {
      sendPending = setTimeout(sendNow, delay);
      // console.log('Queued a send for', delay)
    }
  };
  var throttled = function() {
    nextArgs = arguments;
    // console.log('Called throttle', sendPending, lastSent, nextArgs);
    if (sendPending === null) {
      // console.log('No send pending');
      if (lastSent === null) {
        // console.log('No lastSent, so sending now ... ');
        send(firstWait);
        // console.log('done.');
      } else {
        var elapsed = (new Date()).getTime() - lastSent;
        // console.log('Already last sent, elapsed is', elapsed);
        if (elapsed > wait) {
          // console.log('Elapsed > wait');
          send(0);
        } else {
          // console.log('Waiting: ', wait - elapsed);
          send(wait - elapsed);
        }
      }
    }
  };
  var fireLast = function() {
    if (sendPending) {
      // Cancel it and call send right away
      clearTimeout(sendPending);
      send(0);
    }
    // Otherwise there is nothing to send anyway.
  }
  return {
    throttled: throttled,
    fireLast: fireLast
  };
}

module.exports = throttle;
