var onEvent = require('./events');


var App = function (render, saveState) {
  this.loading = {};
  this.state = {};
  this.sid = {};
  this.render = render;
  this.saveState = saveState;
  this.onPercentageChange = [];
  this.callbacks = [];
  this.loadingTimeout = null;
  // Loading callback condtions 
  this.loadingCallbacks = {};
  this.latestStoreValues = {};
  this.loaded = {};
};


App.prototype.setNumChunks = function(originalID, componentName, numChunks) {
  if (this.loadingTimeout) {
    clearTimeout(this.loadingTimeout);
  }
  // if (if numChunks && typeof self.componentLoaded[componentName] !== 'undefined') {
  //   delete self.componentLoaded[componentName];
  // }
  // console.log('Set num chunks: ', this.sid.id, originalID, componentName, numChunks, this.loading.components);
  var self = this;
  if (self.loading.id !== originalID) {
    throw 'Wrong ID';
  }
  if (self.loading.first) {
    self.loading.first = false;
    for (var i=0; i<self.onPercentageChange.length; i++) {
      // console.log('Calling back', 0);
      self.onPercentageChange[i](0);
    }
  }
  if (typeof self.loading.components[componentName] === "undefined") {
    self.loading.components[componentName] = {expected: null, obtained: null};
  }
  self.loading.components[componentName].expected = numChunks;
  return true;
};

App.prototype.on = function(condition, name, event, callback) {
  var self = this;
  var stores = {}
  var obtained = 0;
  for (var i=0; i<condition.length; i++) {
    if (self.loaded[condition[i]]) {
      stores[condition[i]] = self.latestStoreValues[condition[i]]
      obtained += 1;
    } else {
      break;
    }
  }
  if (condition.length === obtained) {
    callback(stores, event);
  } else {
    this.loadingCallbacks[name] = {
      condition: condition,
      event: event,
      callback: callback,
      obtained: obtained,
    }
  }
};

App.prototype.onLoadComponent = function(componentName) {
  var self = this;
  // Now see of any of the events can be fired
  // console.info('Component', componentName, 'loaded');
  for (var name in self.loadingCallbacks) {
    if (self.loadingCallbacks.hasOwnProperty(name)) {
      var lc = self.loadingCallbacks[name];
      // console.log('Looking at', name, componentName)
      var found = false;
      for (var j=0; j<lc.condition.length; j++) {
        if (lc.condition[j] === componentName) {
          found = true;
          break;
        }
      }
      if (found) {
        lc.obtained += 1;
        // console.info(lc.obtained, lc.condition.length);
        if (lc.obtained === lc.condition.length) {
          // console.info('Got everything we need for '+name+'.');
          var stores = {};
          for (var i=0; i<lc.condition.length; i++) { 
            var storeName = lc.condition[i];
            stores[storeName] = self.latestStoreValues[storeName];
          }
          delete self.loadingCallbacks[name];
          lc.callback(stores, lc.event)
        }
      }
    }
  }
};

App.prototype.obtainedChunks = function(originalID, componentName, chunks, component) {
  // console.log('Obtained: ',this.sid.id, originalID, componentName, chunks, this.loading.components);
  var self = this;
  if (self.loading.id !== originalID) {
    throw 'Wrong ID';
  }
  // console.log('Component', component);
  if (component !== 'undefined') {
    // Make the latest version of the store available
    self.latestStoreValues[componentName] = component;
  }
  self.loading.components[componentName].obtained = chunks;
  // console.log(componentName, self.latestStoreValues[componentName], self.loading.components[componentName].expected , chunks);
  if (typeof self.loaded[componentName] === 'undefined' && self.loading.components[componentName].expected && chunks == self.loading.components[componentName].expected) {
    // console.log('onLoadComponent', componentName);
    self.loaded[componentName] = true;
    self.onLoadComponent(componentName);
  }
  
  // Now calculate a percentage and loop through.
  // console.log(self.loading);
  var totalExpected = 0;
  var totalObtained = 0;
  for (var c in self.loading.components) {
    if (self.loading.components.hasOwnProperty(c)) {
      totalExpected += self.loading.components[c].expected;
      totalObtained += self.loading.components[c].obtained;
    }
  }
  if (totalExpected > 0) {
    var percentage = (totalObtained/totalExpected) * 100;
  } else {
    var percentage = -1;
  }
  // console.log('Calling back percentage', percentage);
  if (true || percentage !== self.loading.lastPercentage) {
    self.loading.lastPercentage = percentage;
    for (var i=0; i<self.onPercentageChange.length; i++) {
      self.onPercentageChange[i](percentage);
    }
    if (percentage === 100) {
      this.loadingTimeout = setTimeout(
        function() {
          self.loading.lastPercentage = percentage;
          for (var i=0; i<self.onPercentageChange.length; i++) {
            self.onPercentageChange[i](-1);
          }
        },
        500
      );
    }
  }
  return true;
}

App.prototype._genNewID = function() {
  // State ID is timestamp (+ counter if last timestamp was the same)
  var now = (new Date()).getTime();
  if (!this.sid.id) {
    this.sid._lastCounter = 0;
    this.sid._lastTimestamp = now;
    this.sid.id = now+'_'+this.sid._lastCounter;
  }
  if (this.sid._lastTimestamp === now) {
    this.sid._lastCounter += 1;
    this.sid.id = now+'_'+this.sid._lastCounter;
  } else {
    this.sid._lastCounter = 0;
    this.sid.id = now+'_'+this.sid._lastCounter;
    this.sid._lastTimestamp = now;
  }
};

App.prototype._updateState = function(newState) {
  // var oldChanges = {};
  for (var key in newState) {
    if (newState.hasOwnProperty(key)) {
      // oldChanges[key] = this.state[key];
      this.state[key] = newState[key];
    }
  }
  // return oldChanges; 
};

// Probably want to throttle this so that changes are batched.
App.prototype.setState = function(changeState) {
  console.info('Set state called', changeState);
  var self = this;
  self._updateState(changeState);
  self._genNewID();
  self.loading = {
    id: self.sid.id,
    components: {},
    first: true,
    lastPercentage: -1
  };
  // Make a copy in case the saveState handler mutates this one
  var sState = {};
  for (var k in this.state) {
    if (this.state.hasOwnProperty(k)) {
      sState[k] = this.state[k];
    }
  }
  this.saveState(sState);
  // var changes = {}
  // for (var key in changeState) {
  //   if (changeState.hasOwnProperty(key)) {
  //     if (typeof this.state[key] === "undefined" || oldChanges[key] !== this.state[key]) {
  //       changes[key] = [oldChanges[key], this.state[key]];
  //     }
  //   }
  // }
  // console.log('rendering...', this.state);
  this.render({
    id: self.sid.id,
    state: self.state,
    changeState: changeState,
    // We need a closure here to avoid trickery React does with re-binding props
    getCurrentID: function() {
      return self.sid.id;
    },
    obtainedChunks: function(originalID, componentName, chunks, component) {
      return self.obtainedChunks(originalID, componentName, chunks, component);
    },
    setNumChunks: function(originalID, componentName, numChunks) {
      return self.setNumChunks(originalID, componentName, numChunks);
    },
    registerPercentage: function(callback) {
      self.onPercentageChange.push(callback);
    },
    setState: function(changeState) {
      return self.setState(changeState);
    },
    on: function(condition, name, event, callback) {
      return self.on(condition, name, event, callback);
    },
    onEvent: onEvent
  });
  // console.log('done');
  return self.sid.id;
};


module.exports = App;
