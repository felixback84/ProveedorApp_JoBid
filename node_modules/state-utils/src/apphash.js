var App = require('./app');
var onEvent = require('./events');
var hash = require('./hash');

var appHash = function(
  // The React component to change on each render
  render,
  // The JS native defaults
  defaults,
  // A function to validate/convert the hash state before defaults are added
  parseState,
  serializeState
) {

  if (!defaults) {
    var defaults = {};
  }
  var _ignoreHashChange = null;

  var app = new App(
    render,
    function(state) {
      // console.log('Updating hash based on', state);
      // Removing the defaults
      // console.log('Updating hash after removing defaults', state);
      if (serializeState) {
        serializeState(state);
      }
      // for (var k in defaults) {
      //   if (defaults.hasOwnProperty(k) && state[k] === defaults[k]) {
      //     delete state[k];
      //   }
      // }
      var h = hash.saveHash(state);
      // console.log('Setting ignore hash change to', h);
      _ignoreHashChange = h;
      // if (h === '#') {
      //   h = undefined;
      // }
      window.location.hash = h;
    }
  );

  var getState = function() {
    var state = hash.getHash(location.hash);
    for (var k in defaults) {
      if (typeof state[k] === "undefined") {
        state[k] = defaults[k]
      }
    }
    if (parseState) {
      state = parseState(state);
    }
    // console.log('State after adding defaults', state);

   // if (state.value) {
   //   state.value = parseInt(state.value);
   // } else {
   //   state.value = 0; // XXX We can't have missing state keys, otherwise when using back, we can't tell whether the value should be missing or not
   // }
    return state;
  };

  window.onback = window.onforward = window.onhashchange = function() {
    // Only trigger if the change isn't one we expected
    // i.e. it came from the user
    if (!_ignoreHashChange || window.location.hash !== _ignoreHashChange) {
      // console.log('onhashchange, forward, or back triggered', window.location.hash, _ignoreHashChange);
      _ignoreHashChange = null;
      app.setState(getState());
    } else {
      // throw window.location.hash;
      console.log('onhashchange, forward, or back triggered, but ignored because it is the same as the current hash', window.location.hash, _ignoreHashChange);
    }
  };
  app.setState(getState());
  return app;
};

module.exports = appHash;
